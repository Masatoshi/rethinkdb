#!/usr/bin/env python

# test-issue-url: https://github.com/rethinkdb/rethinkdb/issues/1774
# test-description: reads and writes can still proceed while a table is sharded

import os, sys, time

# import our testing common
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir, os.path.pardir, 'common')))
import driver, http_admin, utils

# -- constants

databaseName = 'test'
tableName = os.path.splitext(os.path.basename(__file__))[0]

# -- setup

utils.import_pyton_driver()
server = driver.Process()
connection = r.connect(host=server.host, port=server.driver_port)

# make sure we have a clean table with no shards

if databaseName not in r.db_list().run(connection):
	r.db_create(databaseName).run(connection)

try:
	r.table_create(tableName).run(connection)
except r.RqlRuntimeError:
	r.table_drop(tableName).run(connection)
	r.table_create(tableName).run(connection)

# -- thread methods

class fillTable(utils.performContinuousAction):
	def runAction(self):
		tableName = os.path.splitext(os.path.basename(__file__))[0]
		if 'tableName' in self.kwargs:
			tableName = self.kwargs['tableName']
		r.table(tableName).insert({'id':self.sucessCounter + 1, 'data':self.sucessCounter + 1}, durability='hard', upsert=False).run(self.connection)

# -- run the test

# - start filling the table

fillTableProcess = fillTable(connection=r.connect(host=server.host, port=server.driver_port))
time.sleep(3) # give it a moment to have something

# - start reading the table

readTableProcess = utils.performContinuousAction(connection=r.connect(host=server.host, port=server.driver_port), action=r.table(tableName).sample(1))

# - perform the shard

admin = http_admin.ClusterAccess(addresses=[(server.host, server.http_port)])
admin.add_table_shard(tableName, '4')
admin.wait_until_blueprint_satisfied(tableName, print_seconds=False)
time.sleep(1) # another second to add more data

# -- wind down the processes

fillTableProcess.stop()
readTableProcess.stop()

# -- report on errors

print('Created %d records, %d read' % (fillTableProcess.sucessCounter, readTableProcess.sucessCounter))
allPassed = True;

# - fill

for errorMessage, errorCount in fillTableProcess.errorSummary().items():
	allPassed = False
	sys.stderr.write('Failure while writing: %s x %s\n' % (errorCount, errorMessage))

# - read

for errorMessage, errorCount in readTableProcess.errorSummary().items():
	allPassed = False
	sys.stderr.write('Failure while reading: %s x %s\n' % (errorCount, errorMessage))

# - connection is still valid

try:
	r.db_list().run(connection)
	print('Success: conection is still valid')
except r.errors.RqlDriverError:
	allPassed = False
	sys.stderr.write('Failure: The database connnection went stale\n')
	r.connect(host=server.host, port=server.driver_port)

# - everything made it to the database that we expected

actualRecordCount = r.table(tableName).count().run(connection)
if actualRecordCount != fillTableProcess.sucessCounter:
	allPassed = False
	sys.stderr.write('Failure: The count of records in the table (%d) does not match the number we added (%d)\n' % (actualRecordCount, fillTableProcess.sucessCounter))
else:
	print('Success: correct number of records: %d' % actualRecordCount)

expectedSum = (fillTableProcess.sucessCounter * (fillTableProcess.sucessCounter + 1))/2
actualSum = r.table(tableName).sum('data').run(connection)
if expectedSum != actualSum:
	allPassed = False
	sys.stderr.write('Failure: The sum of the data in the table (%d) does not match the number we expected (%d)\n' % (actualSum, expectedSum))
else:
	print('Success: correct sum of records: %d' % expectedSum)

# -- wind down the server

server.check_and_stop()

# --

if allPassed is False:
	sys.exit('Test failed!')

print('Test passed')
